# HelloWorld ROS2 example

For this example, we are going to setup a FIROS2 Bridge to be used to communicate FIWARE Orion contextBroker (NGSIv2 protocol) with ROS2 Listener example.

### Prerequisites:

- Installed and working ROS2 with Fast-RTPS and FIROS2.
- *ROS2* [Talker/Listener example](https://github.com/ros2/ros2/wiki/Linux-Development-Setup#try-some-examples>).

### Bridge library:

In this example, we will use the built-in library *isbridgengsiv2lib*, included with the installation of FIROS2.

### IDL files:

FIROS2 includes a JsonNGSIv2.idl, which will be used by the builtin NGSIv2 libraries. This IDL file is very simple and contains two strings, *entityId* and *data*.

- *entityId* is intended to be filled with the entityId that will use contextBroker to identify the entity "Helloworld", by the **transformation library** (explained later) which will convert ngsiv2 data to ros2 protocol.

- *data* will contain raw JSON received from contextBroker.

To sending data to ROS2 we will use the String_.idl that encapsulates a string compatible with the used one by the *talker/listener* demo in ROS2.

All these IDL files are already generated by *fastrtpsgen*, but maybe they need to be regenerated if *fastrtpsgen* changes in the future.

### Transformation library:

Following the example in templatelib.cpp, we have already created a library to transform from NGSIv2 to ROS2 (only transformation function is shown in order to clarity).

    extern "C" void USER_LIB_EXPORT transform(
            SerializedPayload_t *serialized_input,
            SerializedPayload_t *serialized_output)
    {
        // User types
        std_msgs::msg::dds_::String_ data;
        std_msgs::msg::dds_::String_PubSubType data_pst;

        JsonNGSIv2PubSubType string_pst;
        JsonNGSIv2 string_data;

        // Deserialization
        string_pst.deserialize(serialized_input, &string_data);

        // Custom transformation
        std::stringstream ss(string_data.data());
        Json::Value root;
        Json::CharReaderBuilder jsonReader;
        std::string errs;
        if (Json::parseFromStream(jsonReader, ss, &root, &errs))
        {
        Json::Value data_node = root["data"];
        Json::Value helloworld = data_node[0];
        data.data_("Helloworld: " + helloworld["count"]["value"].asString());
        // Serialization
        serialized_output->reserve(data_pst.m_typeSize);
        data_pst.serialize(&data, serialized_output);
        }
        else
        {
        std::cout  << "Failed to parse" << errs;
        }
    }


The logic is very simple. The function **transform** receives the data as a JsonNGSIv2 structure and creates a String with the data as expected by ROS2.

In both cases, serialization and deserialization are applied as needed by SerializedPayload_t.

### Config.xml

The *config.xml* file used in this example is the following:

    <is>
        <topic_types>
            <type name="std_msgs::msg::dds_::String_">
                <participants>
                    <participant name="ros2"/>
                </participants>
            </type>
        </topic_types>

        <profiles>
            <participant profile_name="ros2">
                <rtps>
                    <builtin>
                        <domainId>0</domainId>
                    </builtin>
                </rtps>
            </participant>

            <publisher profile_name="ros2_publisher">
                <topic>
                    <name>chatter</name>
                    <dataType>std_msgs::msg::dds_::String_</dataType>
                </topic>
                <qos>
                    <partition>
                        <names>
                            <name>rt</name>
                        </names>
                    </partition>
                </qos>
                <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy>
            </publisher>
        </profiles>

        <bridge name="ngsiv2">
            <library>libisbridgengsiv2lib.so</library> <!-- Path to the NGSIv2 library -->

            <reader name="ngsiv2_subscriber">
                <property>
                    <name>host</name>
                    <value>localhost</value>
                </property>
                <property>
                    <name>port</name>
                    <value>1026</value>
                </property>
                <property>
                    <name>id</name>
                    <value>Helloworld</value>
                </property>
                <property>
                    <name>type</name>
                    <value>Helloworld</value>
                </property>
                <property>
                    <name>notifs</name>
                    <value>count</value>
                </property>
                <property>
                    <name>listener_host</name>
                    <value>localhost</value>
                </property>
                <property>
                    <name>listener_port</name>
                    <value>12345</value>
                </property>
            </reader>
        </bridge>

        <connector name="domain_change">
            <reader bridge_name="ngsiv2" reader_name="ngsiv2_subscriber"/>
            <writer participant_profile="ros2" publisher_profile="ros2_publisher"/>
            <transformation file="/path/to/compiled/library/libuserlib.so" function="transform"/>
        </connector>
    </is>


Note that our transformation library will apply to the NGSIv2 listener, so it is declared inside bridge_configuration under the tags "transformFromNGSIv2".

Our ROS2 Topic is chatter in the partition "rt" and with domain 0. Exactly the same configuration that talker/listener ROS2 example uses.
NGSIv2 will be configured to connect with a contextBroker server at localhost in port 1026, and will configure a subscription to any change in any entity of type "Helloworld", and asks to be notified only *count* attribute.

Finally, we will listen to these changes at localhost in port 12345 (internally *libisbridgengsiv2lib* library launches the server to listen at the address specified in the subscription field).

### Run the example

First, we need to compile the example transformation library (remember to have already installed and working ROS2, with Fast-RTPS and FIROS2).
Let's suppose our ROS2 path is **~/ros2**

    $ cd ~/ros2
    $ . ./install/local_setup.bash
    $ cd src/ros2/firos2/examples/helloworld_ros2
    $ mkdir build && cd build
    $ cmake ..
    $ make

In Windows:

    > cd C:\dev\ros2
    > call install\local_setup.bat
    > cd src\ros2\firos2\examples\helloworld_ros2
    > mkdir build && cd build
    > cmake .. -G "Visual Studio 14 2015 Win64"
    > cmake --build . --config Release
    > cd Release

Two auxiliary utilities are compiled:

**cb_create_helloworld**: Allows you to create a "Helloworld" entity with the expected structure in the Orion contextBroker.

    ./cb_create_helloworld localhost:1026

This entity must exist in the contextBroker. If no URL is specified, the "localhost:1026" will be used.

**cb_update_attr**: Allows you to modify an attribute value of an entity in the contextBroker.
The following example will modify *count* attribute of *Helloworld* entity setting its value to 5.

    ./cb_update_attr localhost:1026 Helloworld count n 5

Finally, we are in condition to launch the test.
Let's suppose again that our ROS2 path is **~/ros2**

    $ cd ~/ros2
    $ . ./install/local_setup.bash
    $ cd src/ros2/firos2/examples/helloworld_ros2
    $ firos2 config.xml

In other terminal, launch ROS2 listener example:

    $ cd ~/ros2
    $ . ./install/local_setup.bash
    $ ros2 run demo_nodes_cpp listener

Now, you can check how ROS2's listener receives any change made in the *count* of "Helloworld" using *cb_update_attr*.
